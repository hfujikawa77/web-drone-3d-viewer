<!DOCTYPE html>
<html>
<head>
    <title>ArduPilot SITL 3D Viewer - Cesium Edition</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        html, body, #cesiumContainer {
            width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            width: 140px; 
            color: white; 
            background: rgba(0,0,0,0.7); 
            padding: 10px; 
            z-index: 1000;
            border-radius: 5px;
        }
        .cesium-viewer-bottom {
            display: none;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    <div id="info">
        <h3>SITL 3D Viewer</h3>
        <div>Roll: <span id="roll">0</span>°</div>
        <div>Pitch: <span id="pitch">0</span>°</div>
        <div>Yaw: <span id="yaw">0</span>°</div>
        <div>Alt: <span id="alt">0</span>m</div>
        <div>Pos: X:<span id="posx">0</span> Y:<span id="posy">0</span></div>
        <div>Status: <span id="armStatus">DISARMED</span></div>
        <hr style="margin: 5px 0;">
        <div style="font-size: 0.8em;">
            <div>マウス操作:</div>
            <div>• 左ドラッグ: 回転</div>
            <div>• 右ドラッグ: パン</div>
            <div>• ホイール: ズーム</div>
        </div>
        <hr style="margin: 5px 0;">
        <button onclick="clearPath()" style="width: 100%; margin-bottom: 5px;">軌跡クリア</button>
        <button id="followBtn" onclick="toggleFollowMode()" style="width: 100%; background-color: #007bff; color: white; border: none; padding: 5px;">追従モード: OFF</button>
    </div>

    <script>
        // Initialize Cesium using free plan (no access token required)
        // Uses default OpenStreetMap and basic terrain data
        const viewer = new Cesium.Viewer('cesiumContainer', {
            imageryProvider: new Cesium.OpenStreetMapImageryProvider({
                url: 'https://a.tile.openstreetmap.org/'
            }),
            terrainProvider: new Cesium.EllipsoidTerrainProvider(),
            homeButton: false,
            sceneModePicker: false,
            baseLayerPicker: false,
            navigationHelpButton: false,
            animation: false,
            timeline: false,
            fullscreenButton: false,
            vrButton: false,
            geocoder: false,
            infoBox: false,
            selectionIndicator: false
        });

        // Remove default double click behavior
        viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

        // Store drone data
        let droneEntity = null;
        let homePosition = { lat: 0, lon: 0, alt: 0 };
        let isHomeSet = false;
        let isArmed = false;
        let lastArmedState = null;

        // Flight path tracking
        const MAX_PATH_POINTS = 10000;
        const pathPositions = [];
        let flightPathEntity = null;

        // Follow mode functionality
        let followMode = false;

        // Create drone model as Cesium entity using simple primitives
        function createDroneEntity(position) {
            const droneEntity = viewer.entities.add({
                name: '3DR Iris Quadcopter',
                position: position,
                orientation: new Cesium.CallbackProperty(function(time, result) {
                    if (droneEntity && droneEntity._orientation) {
                        return droneEntity._orientation;
                    }
                    return Cesium.Transforms.headingPitchRollQuaternion(
                        position,
                        new Cesium.HeadingPitchRoll(0, 0, 0)
                    );
                }, false),
                // Main body as box
                box: {
                    dimensions: new Cesium.Cartesian3(1.0, 0.4, 0.6),
                    material: Cesium.Color.DARKGRAY,
                    outline: true,
                    outlineColor: Cesium.Color.BLACK
                },
                // Add a point to make it more visible
                point: {
                    pixelSize: 8,
                    color: Cesium.Color.YELLOW,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 2,
                    heightReference: Cesium.HeightReference.NONE
                },
                // Add label for identification
                label: {
                    text: 'DRONE',
                    font: '12pt monospace',
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    outlineWidth: 2,
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                    pixelOffset: new Cesium.Cartesian2(0, -40),
                    fillColor: Cesium.Color.YELLOW,
                    outlineColor: Cesium.Color.BLACK
                }
            });
            
            // Store reference for orientation updates
            droneEntity._orientation = Cesium.Transforms.headingPitchRollQuaternion(
                position,
                new Cesium.HeadingPitchRoll(0, 0, 0)
            );
            
            return droneEntity;
        }

        // WebSocket connection
        let ws;
        let isConnected = false;

        function connectWebSocket() {
            ws = new WebSocket('ws://localhost:3000');
            
            ws.onopen = () => {
                isConnected = true;
                document.getElementById('info').style.background = 'rgba(0,100,0,0.7)';
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                
                if (data.type === 'heartbeat') {
                    const currentArmedState = data.is_armed;
                    
                    if (lastArmedState === null || lastArmedState !== currentArmedState) {
                        isArmed = currentArmedState;
                        lastArmedState = currentArmedState;
                        
                        const statusElement = document.getElementById('armStatus');
                        if (isArmed) {
                            statusElement.textContent = 'ARMED';
                            statusElement.style.color = '#ff4444';
                        } else {
                            statusElement.textContent = 'DISARMED';
                            statusElement.style.color = '#44ff44';
                        }
                    }
                }
                
                if (data.type === 'attitude') {
                    // Update display
                    document.getElementById('roll').textContent = data.roll.toFixed(1);
                    document.getElementById('pitch').textContent = data.pitch.toFixed(1);
                    document.getElementById('yaw').textContent = data.yaw.toFixed(1);
                    
                    // Update drone orientation if entity exists
                    if (droneEntity && droneEntity.position) {
                        const hpr = new Cesium.HeadingPitchRoll(
                            Cesium.Math.toRadians(-data.yaw),
                            Cesium.Math.toRadians(-data.pitch),
                            Cesium.Math.toRadians(data.roll)
                        );
                        const currentPosition = droneEntity.position.getValue ? 
                            droneEntity.position.getValue(viewer.clock.currentTime) : 
                            droneEntity.position;
                        
                        const orientation = Cesium.Transforms.headingPitchRollQuaternion(
                            currentPosition,
                            hpr
                        );
                        droneEntity._orientation = orientation;
                        droneEntity.orientation = orientation;
                    }
                }
                
                if (data.type === 'position') {
                    // Set home position on first position message
                    if (!isHomeSet && data.lat && data.lon) {
                        homePosition.lat = data.lat;
                        homePosition.lon = data.lon;
                        homePosition.alt = data.relative_alt || 0;
                        isHomeSet = true;
                        console.log('Home position set:', homePosition);
                        
                        // Set initial camera view
                        viewer.camera.setView({
                            destination: Cesium.Cartesian3.fromDegrees(homePosition.lon, homePosition.lat, homePosition.alt + 100),
                            orientation: {
                                heading: 0.0,
                                pitch: -0.5,
                                roll: 0.0
                            }
                        });
                    }
                    
                    // Calculate position from GPS coordinates
                    const currentLat = data.lat;
                    const currentLon = data.lon;
                    const currentAlt = data.relative_alt || 0;
                    
                    // Create Cartesian3 position from GPS coordinates
                    const position = Cesium.Cartesian3.fromDegrees(currentLon, currentLat, currentAlt);
                    
                    // Create or update drone entity
                    if (!droneEntity) {
                        droneEntity = createDroneEntity(position);
                    } else {
                        droneEntity.position = position;
                    }
                    
                    // Update position display (relative to home)
                    if (isHomeSet) {
                        const latDiff = currentLat - homePosition.lat;
                        const lonDiff = currentLon - homePosition.lon;
                        
                        const metersPerDegreeLat = 111111;
                        const metersPerDegreeLon = 111111 * Math.cos(homePosition.lat * Math.PI / 180);
                        
                        const relativeX = lonDiff * metersPerDegreeLon;
                        const relativeY = latDiff * metersPerDegreeLat;
                        
                        document.getElementById('posx').textContent = relativeX.toFixed(1);
                        document.getElementById('posy').textContent = relativeY.toFixed(1);
                    }
                    
                    // Update altitude display
                    document.getElementById('alt').textContent = currentAlt.toFixed(1);
                    
                    // Update flight path
                    if (currentAlt > 0.1) {
                        pathPositions.push(position);
                        
                        // Limit path points
                        if (pathPositions.length > MAX_PATH_POINTS) {
                            pathPositions.shift();
                        }
                        
                        // Update flight path entity
                        if (flightPathEntity) {
                            viewer.entities.remove(flightPathEntity);
                        }
                        
                        if (pathPositions.length > 1) {
                            flightPathEntity = viewer.entities.add({
                                name: 'Flight Path',
                                polyline: {
                                    positions: pathPositions,
                                    width: 3,
                                    material: Cesium.Color.MAGENTA.withAlpha(0.8),
                                    clampToGround: false
                                }
                            });
                        }
                    }
                    
                    // Follow mode camera tracking
                    if (followMode && droneEntity) {
                        viewer.camera.lookAt(position, new Cesium.Cartesian3(0.0, -100.0, 50.0));
                    }
                }
            };
            
            ws.onclose = () => {
                isConnected = false;
                document.getElementById('info').style.background = 'rgba(100,0,0,0.7)';
                setTimeout(connectWebSocket, 2000);
            };
            
            ws.onerror = (error) => {
                // Silent error handling
            };
        }
        
        // Connect on load
        connectWebSocket();
        
        // Clear path function
        function clearPath() {
            pathPositions.length = 0;
            if (flightPathEntity) {
                viewer.entities.remove(flightPathEntity);
                flightPathEntity = null;
            }
        }
        
        // Make clearPath global
        window.clearPath = clearPath;
        
        // Follow mode toggle
        function toggleFollowMode() {
            followMode = !followMode;
            const btn = document.getElementById('followBtn');
            
            if (followMode) {
                btn.textContent = '追従モード: ON';
                btn.style.backgroundColor = '#28a745';
                
                // Enable camera tracking
                if (droneEntity) {
                    const position = droneEntity.position.getValue(viewer.clock.currentTime);
                    viewer.camera.lookAt(position, new Cesium.Cartesian3(0.0, -100.0, 50.0));
                }
            } else {
                btn.textContent = '追従モード: OFF';
                btn.style.backgroundColor = '#007bff';
            }
        }
        
        // Make toggleFollowMode global
        window.toggleFollowMode = toggleFollowMode;
    </script>
</body>
</html>